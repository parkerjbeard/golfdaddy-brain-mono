import os
import uuid
import logging
import json
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime, timedelta
import asyncio

from app.repositories.user_repository import UserRepository
from app.repositories.task_repository import TaskRepository
from app.services.notification_service import NotificationService
from app.services.raci_service import RACIService
from app.config.settings import settings
from app.integrations.ai_integration import AIIntegration

logger = logging.getLogger(__name__)

# Development areas for managers
DEVELOPMENT_AREAS = [
    "strategic_thinking",
    "team_leadership",
    "communication",
    "decision_making",
    "conflict_resolution",
    "delegation",
    "coaching",
    "feedback_delivery",
    "business_acumen",
    "change_management"
]

# Task types
TASK_TYPES = {
    "milestone": "Assessment and goal-setting tasks",
    "development": "Skill practice and implementation tasks",
    "feedback": "Observation and coaching tasks"
}

class ManagerDevelopmentService:
    """
    Service for creating, managing, and tracking manager development tasks
    with full RACI implementation.
    
    This service integrates with AI to generate personalized development 
    content and uses the notification service to keep all stakeholders
    informed according to RACI principles.
    """
    
    def __init__(
        self,
        task_repository: TaskRepository,
        user_repository: UserRepository,
        notification_service: NotificationService,
        raci_service: RACIService,
        ai_integration: AIIntegration
    ):
        self.task_repository = task_repository
        self.user_repository = user_repository
        self.notification_service = notification_service
        self.raci_service = raci_service
        self.ai_integration = ai_integration
    
    async def create_development_task(
        self,
        task_type: str,
        development_area: str,
        manager_id: str,
        title: Optional[str] = None,
        description: Optional[str] = None,
        due_date: Optional[datetime] = None,
        director_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Creates a single management development task with appropriate RACI assignments.
        
        Args:
            task_type: Type of task ("milestone", "development", or "feedback")
            development_area: Area of management development
            manager_id: UUID of the manager
            title: Optional custom title for the task
            description: Optional custom description for the task
            due_date: Optional due date (defaults to 1 week)
            director_id: Optional director ID (will be looked up if not provided)
            
        Returns:
            Dict containing the created task details
        """
        # Validate inputs
        if task_type not in TASK_TYPES:
            raise ValueError(f"Invalid task type. Must be one of: {', '.join(TASK_TYPES.keys())}")
            
        if development_area not in DEVELOPMENT_AREAS:
            raise ValueError(f"Invalid development area. Must be one of: {', '.join(DEVELOPMENT_AREAS)}")
        
        # Look up the manager to get their details
        manager = await self.user_repository.get_user_by_id(manager_id)
        if not manager:
            raise ValueError(f"Manager with ID {manager_id} not found")
        
        # Get or find the director
        if director_id:
            director = await self.user_repository.get_user_by_id(director_id)
            if not director:
                raise ValueError(f"Director with ID {director_id} not found")
        else:
            # Try to find the manager's director
            director = await self.user_repository.get_director_for_manager(manager_id)
            if not director:
                raise ValueError("No director found for manager and none provided")
        
        # Set default due date if not provided
        if not due_date:
            due_date = datetime.now() + timedelta(days=7)
        
        # Generate task details using AI if not provided
        if not title or not description:
            ai_generated_content = await self._generate_task_content(
                task_type, 
                development_area,
                manager["name"] if "name" in manager else "the manager"
            )
            
            if not title:
                title = ai_generated_content["title"]
            
            if not description:
                description = ai_generated_content["description"]
                
            completion_criteria = ai_generated_content["completion_criteria"]
        else:
            # Default completion criteria if not generated by AI
            completion_criteria = [
                f"Complete {development_area.replace('_', ' ')} assessment",
                "Document progress and outcomes",
                "Review with stakeholders"
            ]
            
        # Create the task
        task_id = f"mgmt-dev-{uuid.uuid4().hex[:8]}"
        
        # Set up different RACI assignments based on task type
        raci_assignments = await self._create_raci_assignments(
            task_type, manager, director, task_id
        )
        
        # Prepare task data
        task_data = {
            "task_id": task_id,
            "task_type": task_type,
            "development_area": development_area,
            "title": title,
            "description": description,
            "due_date": due_date.isoformat(),
            "status": "created",
            "completion_criteria": completion_criteria,
            "progress": 0,
            **raci_assignments
        }
        
        # Save task to the database
        created_task = await self.task_repository.create_task(task_data)
        
        # Send notifications to all RACI roles
        await self._notify_stakeholders(task_type, created_task)
        
        return created_task
        
    async def create_development_plan(
        self,
        manager_id: str,
        development_areas: List[str],
        director_id: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Creates a complete development plan with multiple focus areas.
        Each area includes milestone, development, and feedback tasks.
        
        Args:
            manager_id: UUID of the manager
            development_areas: List of development areas to focus on
            director_id: Optional director ID
            
        Returns:
            List of created tasks forming the development plan
        """
        if not development_areas:
            raise ValueError("At least one development area must be provided")
            
        # Validate all areas
        for area in development_areas:
            if area not in DEVELOPMENT_AREAS:
                raise ValueError(f"Invalid development area: {area}")
        
        created_tasks = []
        
        # Create a set of tasks for each development area
        for area in development_areas:
            # Stagger due dates
            milestone_due = datetime.now() + timedelta(days=7)
            development_due = datetime.now() + timedelta(days=14)
            feedback_due = datetime.now() + timedelta(days=21)
            
            # Create milestone task (assessment)
            milestone_task = await self.create_development_task(
                "milestone", 
                area, 
                manager_id, 
                due_date=milestone_due,
                director_id=director_id
            )
            created_tasks.append(milestone_task)
            
            # Create development task (practice)
            development_task = await self.create_development_task(
                "development", 
                area, 
                manager_id, 
                due_date=development_due,
                director_id=director_id
            )
            created_tasks.append(development_task)
            
            # Create feedback task (evaluation)
            feedback_task = await self.create_development_task(
                "feedback", 
                area, 
                manager_id, 
                due_date=feedback_due,
                director_id=director_id
            )
            created_tasks.append(feedback_task)
        
        # Create an overall plan summary
        plan_summary = {
            "manager_id": manager_id,
            "development_areas": development_areas,
            "task_count": len(created_tasks),
            "created_at": datetime.now().isoformat(),
            "tasks": [task["task_id"] for task in created_tasks]
        }
        
        logger.info(f"Created development plan with {len(created_tasks)} tasks for manager {manager_id}")
        
        # Notify the manager about their complete development plan
        manager = await self.user_repository.get_user_by_id(manager_id)
        if manager and "slack_id" in manager:
            await self.notification_service.send_development_plan_notification(
                manager["slack_id"], 
                development_areas, 
                len(created_tasks)
            )
        
        return created_tasks
    
    async def update_task_progress(
        self,
        task_id: str,
        progress: int,
        update_notes: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Updates the progress of a development task.
        
        Args:
            task_id: ID of the task to update
            progress: New progress value (0-100)
            update_notes: Optional notes about the progress update
            
        Returns:
            Updated task data
        """
        # Validate input
        if not 0 <= progress <= 100:
            raise ValueError("Progress must be between 0 and 100")
            
        # Retrieve the task
        task = await self.task_repository.get_task_by_id(task_id)
        if not task:
            raise ValueError(f"Task with ID {task_id} not found")
            
        # Check that it's a development task
        if "task_type" not in task or not task["task_type"] in TASK_TYPES:
            raise ValueError("Not a valid development task")
            
        # Update progress
        update_data = {
            "progress": progress,
            "last_updated": datetime.now().isoformat()
        }
        
        if update_notes:
            update_data["update_notes"] = update_notes
            
        # Update status based on progress
        if progress == 100:
            update_data["status"] = "completed"
        elif progress > 0:
            update_data["status"] = "in_progress"
            
        # Update the task
        updated_task = await self.task_repository.update_task(task_id, update_data)
        
        # Notify relevant stakeholders based on RACI
        if progress == 100:
            # Task completed - notify accountable person
            if "accountable_slack_id" in task:
                await self.notification_service.send_task_completion_notification(
                    task["accountable_slack_id"],
                    task["title"],
                    task["task_id"]
                )
                
            # Also notify informed stakeholders
            if "informed_slack_ids" in task and task["informed_slack_ids"]:
                for slack_id in task["informed_slack_ids"]:
                    await self.notification_service.send_task_completion_notification(
                        slack_id,
                        task["title"],
                        task["task_id"]
                    )
        
        return updated_task
    
    async def generate_feedback(
        self,
        manager_id: str,
        development_area: str,
        context_notes: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Generates AI-powered feedback for a manager in a specific development area.
        
        Args:
            manager_id: ID of the manager
            development_area: Area to provide feedback on
            context_notes: Optional context or observations
            
        Returns:
            Dictionary containing structured feedback
        """
        # Get manager data
        manager = await self.user_repository.get_user_by_id(manager_id)
        if not manager:
            raise ValueError(f"Manager with ID {manager_id} not found")
            
        # Get manager's recent tasks in this area
        recent_tasks = await self.task_repository.get_tasks_by_user_and_area(
            manager_id, development_area, limit=5
        )
        
        # Prepare context for AI
        manager_name = manager.get("name", "the manager")
        manager_role = manager.get("role", "manager")
        recent_task_titles = [task.get("title", "") for task in recent_tasks]
        recent_progress = [task.get("progress", 0) for task in recent_tasks]
        
        # Generate a detailed feedback prompt
        prompt = self._create_feedback_prompt(
            manager_name,
            manager_role,
            development_area,
            recent_task_titles,
            recent_progress,
            context_notes
        )
        
        # Call the AI to generate feedback
        ai_response = await self.ai_integration.generate_text(prompt)
        
        # Process and structure the response
        try:
            feedback = self._process_feedback_response(ai_response, development_area)
            
            # Log the successful feedback generation
            logger.info(f"Generated feedback for manager {manager_id} in area: {development_area}")
            
            return feedback
        except Exception as e:
            logger.error(f"Failed to process AI feedback response: {str(e)}")
            raise ValueError("Failed to generate structured feedback")
    
    async def get_manager_development_summary(
        self, 
        manager_id: str
    ) -> Dict[str, Any]:
        """
        Provides a summary of a manager's development across all areas.
        
        Args:
            manager_id: ID of the manager
            
        Returns:
            Summary of development progress
        """
        # Get manager data
        manager = await self.user_repository.get_user_by_id(manager_id)
        if not manager:
            raise ValueError(f"Manager with ID {manager_id} not found")
            
        # Get all tasks for the manager
        all_tasks = await self.task_repository.get_tasks_for_user(manager_id)
        
        # Organize tasks by development area
        tasks_by_area = {}
        for area in DEVELOPMENT_AREAS:
            tasks_by_area[area] = []
            
        for task in all_tasks:
            if "development_area" in task and task["development_area"] in DEVELOPMENT_AREAS:
                tasks_by_area[task["development_area"]].append(task)
        
        # Calculate progress for each area
        area_progress = {}
        for area, tasks in tasks_by_area.items():
            if not tasks:
                area_progress[area] = 0
            else:
                total_progress = sum(task.get("progress", 0) for task in tasks)
                area_progress[area] = total_progress / (len(tasks) * 100) * 100 if tasks else 0
        
        # Calculate overall progress
        total_progress = sum(area_progress.values())
        overall_progress = total_progress / len(DEVELOPMENT_AREAS) if DEVELOPMENT_AREAS else 0
        
        # Find strengths and areas for improvement
        strengths = sorted(area_progress.items(), key=lambda x: x[1], reverse=True)[:3]
        weaknesses = sorted(area_progress.items(), key=lambda x: x[1])[:3]
        
        # Create summary
        summary = {
            "manager_id": manager_id,
            "manager_name": manager.get("name", ""),
            "overall_progress": overall_progress,
            "area_progress": area_progress,
            "strengths": [area for area, _ in strengths],
            "improvement_areas": [area for area, _ in weaknesses],
            "total_tasks": len(all_tasks),
            "completed_tasks": sum(1 for task in all_tasks if task.get("status") == "completed"),
            "in_progress_tasks": sum(1 for task in all_tasks if task.get("status") == "in_progress"),
            "pending_tasks": sum(1 for task in all_tasks if task.get("status") == "created")
        }
        
        return summary
    
    # --- Helper methods ---
    
    async def _generate_task_content(
        self,
        task_type: str,
        development_area: str,
        manager_name: str
    ) -> Dict[str, Any]:
        """
        Uses AI to generate task title, description, and completion criteria.
        """
        # Create prompt based on task type and development area
        area_display = development_area.replace("_", " ")
        
        if task_type == "milestone":
            prompt = f"""
            Create a milestone assessment task for {manager_name} focused on '{area_display}' management skills.
            The task should help the manager assess their current capabilities and set goals.
            
            Provide:
            1. A short, specific task title
            2. A detailed description of what the manager needs to do
            3. 3-5 specific completion criteria that will indicate the milestone is complete
            
            Format the response as JSON with title, description, and completion_criteria (an array) fields.
            """
        elif task_type == "development":
            prompt = f"""
            Create a skill development task for {manager_name} to improve '{area_display}' management capabilities.
            The task should involve actively practicing and implementing new techniques.
            
            Provide:
            1. A short, specific task title
            2. A detailed description of the development activity
            3. 3-5 specific completion criteria that will indicate the development activity is complete
            
            Format the response as JSON with title, description, and completion_criteria (an array) fields.
            """
        else:  # feedback
            prompt = f"""
            Create a feedback task related to {manager_name}'s '{area_display}' management capabilities.
            This task will be assigned to the manager's director or supervisor to provide structured feedback.
            
            Provide:
            1. A short, specific task title
            2. A detailed description of how the feedback should be gathered and delivered
            3. 3-5 specific completion criteria for giving effective feedback
            
            Format the response as JSON with title, description, and completion_criteria (an array) fields.
            """
        
        # Call the AI integration
        ai_response = await self.ai_integration.generate_text(prompt)
        
        # Parse the response
        try:
            content = json.loads(ai_response)
            required_fields = ["title", "description", "completion_criteria"]
            
            # Validate response has required fields
            for field in required_fields:
                if field not in content:
                    raise ValueError(f"AI response missing required field: {field}")
                    
            return content
        except json.JSONDecodeError:
            # Fallback content if AI doesn't return valid JSON
            return {
                "title": f"{task_type.capitalize()} for {area_display}",
                "description": f"Complete a {task_type} task related to {area_display} management skills.",
                "completion_criteria": [
                    f"Complete {area_display} assessment",
                    "Document progress and outcomes",
                    "Review with stakeholders"
                ]
            }
    
    async def _create_raci_assignments(
        self,
        task_type: str,
        manager: Dict[str, Any],
        director: Dict[str, Any],
        task_id: str
    ) -> Dict[str, Any]:
        """
        Creates appropriate RACI role assignments based on task type.
        """
        # Get team members and peers for consulted/informed roles
        direct_reports = await self.user_repository.get_direct_reports(manager["id"])
        peers = await self.user_repository.get_peers(manager["id"])
        
        # Extract just the IDs and names
        direct_report_ids = [user["id"] for user in direct_reports]
        direct_report_slack_ids = [user.get("slack_id", "") for user in direct_reports]
        direct_report_names = [user.get("name", f"Employee {i+1}") for i, user in enumerate(direct_reports)]
        
        peer_ids = [user["id"] for user in peers][:2]  # Limit to 2 peers
        peer_slack_ids = [user.get("slack_id", "") for user in peers][:2]
        peer_names = [user.get("name", f"Peer {i+1}") for i, user in enumerate(peers)][:2]
        
        # Base RACI structure
        raci = {
            "responsible_id": "",
            "responsible_slack_id": "",
            "responsible_name": "",
            
            "accountable_id": "",
            "accountable_slack_id": "",
            "accountable_name": "",
            
            "consulted_ids": [],
            "consulted_slack_ids": [],
            "consulted_names": [],
            
            "informed_ids": [],
            "informed_slack_ids": [],
            "informed_names": []
        }
        
        # Assign different RACI roles based on task type
        if task_type == "milestone":
            # Manager is responsible, director is accountable
            raci["responsible_id"] = manager["id"]
            raci["responsible_slack_id"] = manager.get("slack_id", "")
            raci["responsible_name"] = manager.get("name", "Manager")
            
            raci["accountable_id"] = director["id"]
            raci["accountable_slack_id"] = director.get("slack_id", "")
            raci["accountable_name"] = director.get("name", "Director")
            
            # Peers are consulted
            raci["consulted_ids"] = peer_ids
            raci["consulted_slack_ids"] = peer_slack_ids
            raci["consulted_names"] = peer_names
            
            # Direct reports are informed
            raci["informed_ids"] = direct_report_ids[:3]  # Limit to 3
            raci["informed_slack_ids"] = direct_report_slack_ids[:3]
            raci["informed_names"] = direct_report_names[:3]
            
        elif task_type == "development":
            # Manager is both responsible and accountable
            raci["responsible_id"] = manager["id"]
            raci["responsible_slack_id"] = manager.get("slack_id", "")
            raci["responsible_name"] = manager.get("name", "Manager")
            
            raci["accountable_id"] = manager["id"]
            raci["accountable_slack_id"] = manager.get("slack_id", "")
            raci["accountable_name"] = manager.get("name", "Manager")
            
            # Director and peers are consulted
            consulted_ids = [director["id"]] + peer_ids
            consulted_slack_ids = [director.get("slack_id", "")] + peer_slack_ids
            consulted_names = [director.get("name", "Director")] + peer_names
            
            raci["consulted_ids"] = consulted_ids
            raci["consulted_slack_ids"] = consulted_slack_ids
            raci["consulted_names"] = consulted_names
            
            # Direct reports are informed
            raci["informed_ids"] = direct_report_ids[:3]
            raci["informed_slack_ids"] = direct_report_slack_ids[:3]
            raci["informed_names"] = direct_report_names[:3]
            
        else:  # feedback task
            # Director is responsible and accountable
            raci["responsible_id"] = director["id"]
            raci["responsible_slack_id"] = director.get("slack_id", "")
            raci["responsible_name"] = director.get("name", "Director")
            
            raci["accountable_id"] = director["id"]
            raci["accountable_slack_id"] = director.get("slack_id", "")
            raci["accountable_name"] = director.get("name", "Director")
            
            # Manager is consulted
            raci["consulted_ids"] = [manager["id"]]
            raci["consulted_slack_ids"] = [manager.get("slack_id", "")]
            raci["consulted_names"] = [manager.get("name", "Manager")]
            
            # HR or peers might be informed
            raci["informed_ids"] = peer_ids[:2]
            raci["informed_slack_ids"] = peer_slack_ids[:2]
            raci["informed_names"] = peer_names[:2]
        
        # Register with RACI service
        await self.raci_service.register_raci_assignments(task_id, raci)
        
        return raci
    
    async def _notify_stakeholders(
        self,
        task_type: str,
        task: Dict[str, Any]
    ) -> None:
        """
        Sends appropriate notifications to stakeholders based on RACI roles.
        """
        # Notify the responsible person
        if "responsible_slack_id" in task and task["responsible_slack_id"]:
            await self.notification_service.send_task_creation_notification(
                task["responsible_slack_id"],
                "responsible",
                task["title"],
                task["task_id"],
                task["due_date"]
            )
        
        # Notify the accountable person (if different from responsible)
        if (
            "accountable_slack_id" in task and 
            task["accountable_slack_id"] and
            task["accountable_slack_id"] != task.get("responsible_slack_id", "")
        ):
            await self.notification_service.send_task_creation_notification(
                task["accountable_slack_id"],
                "accountable",
                task["title"],
                task["task_id"],
                task["due_date"]
            )
        
        # Notify consulted people (batch for efficiency)
        if "consulted_slack_ids" in task and task["consulted_slack_ids"]:
            for slack_id in task["consulted_slack_ids"]:
                if slack_id:  # Only if valid slack ID
                    await self.notification_service.send_task_creation_notification(
                        slack_id,
                        "consulted",
                        task["title"],
                        task["task_id"],
                        task["due_date"]
                    )
        
        # Informed people just get a simpler notification
        if "informed_slack_ids" in task and task["informed_slack_ids"]:
            for slack_id in task["informed_slack_ids"]:
                if slack_id:  # Only if valid slack ID
                    await self.notification_service.send_task_info_notification(
                        slack_id,
                        task["title"],
                        task["responsible_name"],
                        task["task_id"]
                    )
                    
    def _create_feedback_prompt(
        self,
        manager_name: str,
        manager_role: str,
        development_area: str,
        recent_task_titles: List[str],
        recent_progress: List[int],
        context_notes: Optional[str]
    ) -> str:
        """
        Creates a detailed prompt for AI feedback generation.
        """
        area_display = development_area.replace("_", " ")
        
        # Build the context section
        context = f"The manager has recently worked on: {', '.join(recent_task_titles)}" if recent_task_titles else ""
        
        if context_notes:
            context += f"\n\nAdditional context: {context_notes}"
        
        # Average progress if available
        progress_info = ""
        if recent_progress:
            avg_progress = sum(recent_progress) / len(recent_progress)
            progress_info = f"The manager has made approximately {avg_progress:.1f}% progress on recent tasks."
        
        # Create the full prompt
        prompt = f"""
        Generate professional feedback for {manager_name}, who is in a {manager_role} role.
        Focus specifically on their '{area_display}' capabilities.
        
        {context}
        
        {progress_info}
        
        Provide:
        1. A brief summary of strengths in this area
        2. 2-3 specific areas for improvement
        3. 3-5 actionable suggestions with specific techniques or approaches
        4. A recommended timeline for implementing changes
        
        Format the response as JSON with the following fields:
        - strengths: An array of strength statements
        - improvement_areas: An array of areas needing improvement
        - suggestions: An array of specific actionable suggestions
        - timeline: A string describing the recommended implementation timeline
        """
        
        return prompt
    
    def _process_feedback_response(
        self,
        ai_response: str,
        development_area: str
    ) -> Dict[str, Any]:
        """
        Processes AI response into structured feedback.
        """
        try:
            # Try to parse as JSON first
            feedback_data = json.loads(ai_response)
            
            # Ensure required fields exist
            required_fields = ["strengths", "improvement_areas", "suggestions", "timeline"]
            for field in required_fields:
                if field not in feedback_data:
                    raise ValueError(f"AI response missing required field: {field}")
            
            # Add metadata
            feedback_data["generated_at"] = datetime.now().isoformat()
            feedback_data["development_area"] = development_area
            
            return feedback_data
            
        except (json.JSONDecodeError, ValueError) as e:
            # If not valid JSON, attempt to structure it
            logger.warning(f"AI didn't return valid JSON: {str(e)}. Attempting to structure response.")
            
            # Simple fallback to structured format
            return {
                "strengths": ["The manager shows potential in this area"],
                "improvement_areas": ["Needs more structured development"],
                "suggestions": [
                    "Implement a regular practice routine",
                    "Seek feedback from team members",
                    "Study examples of excellence in this area"
                ],
                "timeline": "Implement over the next 30 days with weekly check-ins",
                "generated_at": datetime.now().isoformat(),
                "development_area": development_area,
                "raw_response": ai_response
            } 